<!doctype html>
<html lang="ja">
<head>
 <meta charset="utf-8">
 <meta name="viewport" content="width=device-width, initial-scale=1.0">
 <title>WebRTC</title>
 <script src="https://unpkg.com/mqtt@5.10.3/dist/mqtt.js"></script>
 <script src="https://cdnjs.cloudflare.com/ajax/libs/paho-mqtt/1.1.0/paho-mqtt.js"></script>
<!-- <script src="https://git.eclipse.org/c/paho/org.eclipse.paho.mqtt.javascript.git/plain/src/mqttws31.js"></script>-->
<style>
  button {
    width: 10em;
    height:3em;
    font-size: 1.5em;
  }
</style>
</head>
<body>
  <div>WebRTC</div>
  <button type="button" onclick="startVideo();">Start Video</button>
  <button type="button" onclick="stopVideo();">Stop Video</button>
  <button type="button" onclick="connect();">Peer Connect</button>
  <button type="button" onclick="hangUp();">Peer Hang Up</button> 
  <div>
    <video id="local_video" autoplay style="width: 240px; height: 180px; border: 1px solid black;"></video>
    <video id="remote_video" autoplay style="width: 240px; height: 180px; border: 1px solid black;"></video>
  </div>
  <p id="status">
    状態
  </p>
  <p>SDP to send:<br />
    <textarea id="text_for_send_sdp" rows="5" cols="60" readonly="readonly" required></textarea>
  </p>
  <p>SDP received:&nbsp;
    <br />
    <textarea id="text_for_receive_sdp" rows="5" cols="60"></textarea>
  </p>
</body>
<script type="text/javascript">
  
  let localVideo = document.getElementById('local_video');
  let remoteVideo = document.getElementById('remote_video');
  let status = document.getElementById('status');
  let localStream = null;
  let peerConnection = null;
  let peerStarted = false;
  var mediaConstraints = {
    'mandatory': {
      'OfferToReceiveAudio':true,
      'OfferToReceiveVideo':true,
    }
  };

  let textForSendSdp = document.getElementById('text_for_send_sdp');
  let textToReceiveSdp = document.getElementById('text_for_receive_sdp');
  // --- prefix -----
  navigator.getUserMedia  = navigator.getUserMedia    || navigator.webkitGetUserMedia ||
                            navigator.mozGetUserMedia || navigator.msGetUserMedia;
  RTCPeerConnection = window.RTCPeerConnection || window.webkitRTCPeerConnection || window.mozRTCPeerConnection;
  RTCSessionDescription = window.RTCSessionDescription || window.webkitRTCSessionDescription || window.mozRTCSessionDescription;


// EMQX MQTTブローカー  に接続 =============================
// Server: broker.emqx.io
// TCP Port: 1883
// WebSocket Port: 8083
// SSL/TLS Port: 8883
// WebSocket Port(SSL): 8084

// const mqtt = require('mqtt'); // MQTT通信プロトコルのモジュールを呼び出す。（これ要らなくなった。）
// const fs = require('fs');
// const path = require('path');

//const KEY = fs.readFileSync(path.join(__dirname, '/tls-key.pem'))
//const CERT = fs.readFileSync(path.join(__dirname, '/tls-cert.pem'))
const TRUSTED_CA_LIST = './emqxsl-ca.crt';

// MQTT 接続情報
// 接続先：// ebb8eeee.ala.asia-southeast1.emqxsl.com
// user名: user
// password: password 
// MQTT over TLS/SSL ポート：
// 8883
// WebSocket over TLS/SSL ポート：
// 8084
// APIキー = https://ebb8eeee.ala.asia-southeast1.emqxsl.com:8443/api/v5

  var clientId = 'mqttjs_' + Math.random().toString(16).substr(2, 8); // 適当なクライアントID。今回は一意にしません
//  const border = 'broker.emqx.io';
  const broker = 'ebb8eeee.ala.asia-southeast1.emqxsl.com';
  var user_name = "user"; 
  var pass = "password";  
  let host = 'wss://' + broker + ':8084/mqtt';              // MQTTブローカー
  const topic_offer = user_name + '/signaling/offer';       // MQTT用のトピック名を決めて置く
  const topic_answer = user_name + '/signaling/answer';
  const topic_candidate = user_name + '/signaling/candidate';

  const options = {  // Create an MQTT client instance
    keepalive:60,
    clientId: clientId,
    protocolId:'MQTT',
    protocolVersion: 4,
    username: user_name,
    password: pass,
    clean: true,
    reconnectPeriod: 1000,
    connectTimeout: 30*1000,
//    key: KEY,
//    cert: CERT,
//    rejectUnauthorized: true,
    ca: TRUSTED_CA_LIST,    // CA証明書
  }
  console.log('MQTT: clientId= ' + clientId);
  console.log('MQTT: Connecting MQTT client ...');
  status.textContent = 'Connecting MQTT client ...';

  const client  = mqtt.connect(host, options); // MQTT（シグナリングサーバー）に接続する

  function buildTopic(subtitle) {   // topic名をその都度作成
    var topic = user_name + '/signaling/' + subtitle;
    return topic;
  }

  client.on('connect', function () {  // MQTTに接続出来たら
    console.log('MQTT: Connected');
    status.textContent = 'MQTT Connected';
    subscribe('offer');               // offerを待ち受ける。(subscribe=購読する)
  })

  client.on('message', function(topic, message, packet){  // MQTT にメッセージが来たら呼ばれる
    status.textContent = 'MQTT message recived';
    console.log(`MQTT: onmessage ==> Topic: ${topic}, QoS: ${packet.qos}`);
    switch(topic){
      case topic_offer:   // "offer"トピックが来たら
        console.log('MQTT: Received offer SDP ...');
        textToReceiveSdp.value = message.sdp;
        setOfferText(message.sdp);  // 新たなpeer接続を作り。 相手のSDPをセットする
        makeAnswer();               // 自分のSDPをanswerにセットする
        break;
      case topic_answer:  // "anser"トピックが来たら
        console.log('MQTT: Received answer SDP ...');
        textToReceiveSdp.value = message.sdp;
        setAnswerText(message.sdp); // 相手SDPをpeerにセットする
        break;
      case topic_candidate:         // ICE candidateが来たら
        console.log('MQTT: Received ICE candidate ...');
        let candidate = new RTCIceCandidate(message.ice);
        console.log(candidate);
        addIceCandidate(candidate);   // 覚えさせる
        break;
      default:
        console.warn('Bad SDP topic');
    }
  })
  
  client.on('reconnect', function () {  // 切断後に再接続でトリガ
    status.textContent = 'MQTT reconnect';   
    console.log('MQTT: Reconnecting...');
  })

  client.on('close', function () {      // 切断後にトリガ
    status.textContent = 'MQTT close';
    console.log('MQTT: Disconnected')
  })

//=========================================================
  // start PeerConnection
  function connect() {
    if (! peerConnection) { // まだコネクションが確立してなかったら
      console.log('Peer: make Offer');
      makeOffer();          //  Offer SDPを作成し送信する。（非同期処理）
    }
    else {
      console.warn('Peer: already exist.');
    }
  }

  // close PeerConnection
  function hangUp() {
    if (peerConnection) {
      console.log('Peer: Hang up.');
      peerConnection.close();
      peerConnection = null;
      pauseVideo(remoteVideo);
    }
    else {
      console.warn('peer NOT exist.');
    }
  }

  function subscribe(subtitle) {      // 購読予約する
//    client.onMessageArrived = onMessageArrived;    // コールバック関数を登録します
    var topic = buildTopic(subtitle); // topic名を生成
    client.subscribe(topic);          // topicで待ち受ける
    console.log('MQTT: client ID: ' + clientId);
    console.log('MQTT: Subscribe topic = ' + topic);
  }

  function unsubscribe(subtitle) {    // 購読予約を解除する
    var topic = buildTopic(subtitle);  // topic名を生成
    client.unsubscribe(topic);        // topic名の予約を解除する
    console.log('MQTT: unSubscribe topic = ' + topic);    
  }

  function sendSDPTextMQTT(subtitle, text){
   var topic = buildTopic(subtitle);  // topic名を決める
//   message = new Paho.Message(text);  // messageを作る
//   message.destinationName = topic;
   client.publish(topic, text);       // 送信する
   console.log('MQTT: client ID: ' + clientId);
   console.log('MQTT: Publish topic = ' + topic);
  }
/*
  function sendSdp(sessionDescription) {  // wsでSDPを送信する
    console.log('sending sdp ...');
    textForSendSdp.value = sessionDescription.sdp;  // テキストエリアに表示

    var topic = sessionDescription.type;
    message = new Paho.MQTT.Message(sessionDescription.sdp);
    message.destinationName = topic;
    client.send(message);
  }

  function sendIceCandidate(candidate) {
    console.log('---sending ICE candidate ---');
    let obj = { type: 'candidate', ice: candidate };
    let message = JSON.stringify(obj);
    console.log('sending candidate=' + message);
    client.send(message);
  }
*/
  function setOfferText(text) {
    peerConnection = prepareNewConnection();  // offerが送られた相手と新たにpeer接続を作る
    var offer = new RTCSessionDescription({
      type : 'offer',
      sdp : text,
    });
    peerConnection.setRemoteDescription(offer); // 相手のSDPをセットする
  }
  
  function setAnswerText(text) {
    if (! peerConnection) {
      console.error('Peer: peerConnection NOT exist!');
      return;
    }
    var answer = new RTCSessionDescription({
      type : 'answer',
      sdp : text,
    });
    peerConnection.setRemoteDescription(answer);  // 相手SDPをセット
  }

  function makeAnswer(evt) {
    console.log('Peer: sending Answer. Creating remote session description...' );
    if (! peerConnection) {
      console.error('Peer: peerConnection NOT exist!');
      return;
    }
    peerConnection.createAnswer(function (sessionDescription) { // in case of success
      peerConnection.setLocalDescription(sessionDescription);   // 自分のSDPをセットする
    }, function () { // in case of error
      console.log("Peer: Create Answer failed");
    }, mediaConstraints);
  }
/*
  function onSDPText() {
   var text = textToReceiveSDP.value;
   if (peerConnection) {
    onAnswerText(text);
   }
   else {
    onOfferText(text);
   }
   textToReceiveSDP.value ="";
  }
*/ 

  function onOfferText(text) {
    setOfferText(text); // 新たなpeer接続を作り
    makeAnswer();       // answerを送る
  }

  function onAnswerText(text) {
    console.log("Peer: Received answer text...")
    setAnswerText(text);
  }

  
/*
  // Receive messages
  client.on('message', function (topic, message) {
    console.log(message.toString());
    if(message.type === 'offer'){
      console.log('Received offer ...');
      textToReceiveSdp.value = message.sdp;
      let offer = new RTCSessionDescription(message);
      setOffer(offer);      
    }
    else if (message.type === 'answer') { // answerメッセージなら
      // --- got answer ---
      console.log('Received answer ...');
      textToReceiveSdp.value = message.sdp;
      let answer = new RTCSessionDescription(message);
      setAnswer(answer);
    }
    else if (message.type === 'candidate') {  // 相手からICE candidateを受け取ったら
      // --- got ICE candidate ---
      console.log('Received ICE candidate ...');
      let candidate = new RTCIceCandidate(message.ice);
      console.log(candidate);
      addIceCandidate(candidate);   // 覚えさせる
    }   
//    client.end()
  })
*/
 /*
  let ws = new WebSocket(wsUrl);
  ws.onopen = function(evt) {
    console.log('ws open()');
  };
  ws.onerror = function(err) {
    console.error('ws onerror() ERR:', err);
  };
  ws.onmessage = function(evt) {  // MQTTからメッセージが来たら
    console.log('ws onmessage() data:', evt.data);
    let message = JSON.parse(evt.data);
    if (message.type === 'offer') {     // offerメッセージなら
      // -- got offer ---
      console.log('Received offer ...');
      textToReceiveSdp.value = message.sdp;
      let offer = new RTCSessionDescription(message);
      setOffer(offer);  
    }
    else if (message.type === 'answer') { // answerメッセージなら
      // --- got answer ---
      console.log('Received answer ...');
      textToReceiveSdp.value = message.sdp;
      let answer = new RTCSessionDescription(message);
      setAnswer(answer);
    }
    else if (message.type === 'candidate') {  // 相手からICE candidateを受け取ったら
      // --- got ICE candidate ---
      console.log('Received ICE candidate ...');
      let candidate = new RTCIceCandidate(message.ice);
      console.log(candidate);
      addIceCandidate(candidate);   // 覚えさせる
    }
  };
*/


  // ---------------------- media handling ----------------------- 
  // start local video
  function startVideo() {
    getDeviceStream({video: true, audio: false})
    .then(function (stream) { // success
      localStream = stream;
      playVideo(localVideo, stream);
    }).catch(function (error) { // error
      console.error('getUserMedia error:', error);
      return;
    });
  }

  // stop local video
  function stopVideo() {
    pauseVideo(localVideo);
    stopLocalStream(localStream);
  }

  function stopLocalStream(stream) {
    let tracks = stream.getTracks();
    if (! tracks) {
      console.warn('NO tracks');
      return;
    }
    
    for (let track of tracks) {
      track.stop();
    }
  }
  
  function getDeviceStream(option) {
    if ('getUserMedia' in navigator.mediaDevices) {
      console.log('navigator.mediaDevices.getUserMadia');
      return navigator.mediaDevices.getUserMedia(option);
    }
    else {
      console.log('wrap navigator.getUserMadia with Promise');
      return new Promise(function(resolve, reject){    
        navigator.getUserMedia(option,
          resolve,
          reject
        );
      });      
    }
  }

  function playVideo(element, stream) {
    if ('srcObject' in element) {
      element.srcObject = stream;
    }
    else {
      element.src = window.URL.createObjectURL(stream);
    }
    element.play();
    element.volume = 0;
  }

  function pauseVideo(element) {
    element.pause();
    if ('srcObject' in element) {
      element.srcObject = null;
    }
    else {
      if (element.src && (element.src !== '') ) {
        window.URL.revokeObjectURL(element.src);
      }
      element.src = '';
    }
  }

  /*
  // ----- hand signaling ----
  function onSdpText() {  // [Receive remote SDP]ボタンがクリックされた時の処理（ハンドシェイク用）
    let text = textToReceiveSdp.value;
    if (peerConnection) {
      console.log('Received answer text...');
      let answer = new RTCSessionDescription({
        type : 'answer',
        sdp : text,
      });
      setAnswer(answer);
    }
    else {
      console.log('Received offer text...');
      let offer = new RTCSessionDescription({
        type : 'offer',
        sdp : text,
      });
      setOffer(offer);
    }
    textToReceiveSdp.value ='';
  }
 */

  // ---------------------- connection handling -----------------------
  function prepareNewConnection() {     // 通信相手ごとに作る
     var peer = new RTCPeerConnection({                // RTCPeerConnectionを初期化 
  //    offerToReceiveAudio: 1,
  //    offerToReceiveVideo: 0,
      iceServers: [
        {"urls": "stun:stun.l.google.com:19302"},     // グローバルアドレスを得る
        {"urls": "stun:stun1.l.google.com:19302"},
        {"urls": "stun:stun2.l.google.com:19302"},
      ],
    });
    
    // SDPの交換が終わると、P2P通信に相手の映像/音声が含まれていればイベントが発生します。
    peer.ontrack = function(event) {     // .ontrackイベントが発生したら
      console.log('Peer: peer.ontrack()');
      let stream = event.streams[0];
      playVideo(remoteVideo, stream);    // 映像を再生する
    };

    peer.addEventListener("addstream", onRemoteStreamAdded, false);
    peer.addEventListener("removestream", onRemoteStreamRemoved, false);

    function onRemoteStreamAdded(event) {
      remoteVideo.src = window.webkitURL.createObjectURL(event.stream);
    }

    function onRemoteStreamRemoved(event) {
      remoteVideo.src = "";
    }

    peer.onicecandidate = function (evt) { // local ICE candidateが収集される度に呼び出される。
      if (evt.candidate) {                // ICE candidate が収集された場合
        console.log('Peer: ');
        console.log(evt.candidate);
        // Vanilla ICE の場合には、何もしない
        // Tricle ICE の場合は、ここでICE candidateを相手に送る
        // sendIceCandidate(evt.candidate);  // ICE candidateを相手に送る (Trickle ICE の場合)

      } else {                              // ICE candidateの収集が完了した時
        console.log('Peer: ICE candidate compleat.');
        let type = peer.localDescription.type;
        let sdp  = peer.localDescription.sdp;
        console.log('Peer: local SDP type: ' + type);
        textForSendSdp.value = sdp;              // テキストエリア(送信用)に表示 
        // Trickle ICE の場合は、何もしない
        // Vanilla ICE の場合には、ICE candidateを含んだSDPを相手に送る
        sendSDPTextMQTT(type, sdp);             // シグナリング(MQTT)に送信
      }
    };

    // --- when need to exchange SDP ---
    peer.onnegotiationneeded = function(evt) {
      console.log('Peer: -- onnegotiationneeded() ---');
    };

    // --- other events ----
    peer.onicecandidateerror = function (evt) {
      console.error('Peer: ICE candidate ERROR:', evt);
    };

    peer.onsignalingstatechange = function() {
      console.log('Peer: == signaling status=' + peer.signalingState);
    };

    peer.oniceconnectionstatechange = function() {
      console.log('Peer: == ice connection status=' + peer.iceConnectionState);
      if (peer.iceConnectionState == 'completed') {
        console.log("Peer: candidate complete");
      }
      if (peer.iceConnectionState === 'disconnected') {
        console.log('Peer: -- disconnected --');
        hangUp();
      }
    };

    peer.onicegatheringstatechange = function() {
      console.log('Peer: ==***== ice gathering state=' + peer.iceGatheringState);
    };
    
    peer.onconnectionstatechange = function() {
      console.log('Peer: ==***== connection state=' + peer.connectionState);
    };

    peer.onremovestream = function(event) {
      console.log('Peer: -- peer.onremovestream()');
      pauseVideo(remoteVideo);
    };
    
    // 通信対象の映像/音声ストリームを追加する
    if (localStream) {
      console.log('Peer: Adding local stream...');
      peer.addStream(localStream);
    }
    else {
      console.warn('Peer: no local stream, but continue.');
    }
    return peer;
  }

  function makeOffer() {    // SDPを作成し送信する
    unsubscribe("offer");   // offerの待ち受けを解除
    subscribe("answer");    // answerを待ち受ける
    peerConnection = prepareNewConnection();  // RTCPeerConnectionを生成し、必要なメッセージハンドラを設定

    peerConnection.createOffer()              // Offer SDPを生成 （非同期で処理が行われるので、.then()で受け止める。Promise）
      .then(function (sessionDescription) {
        console.log('Peer: createOffer() succsess in promise. type = ' + sessionDescription.type);
//        textForSendSdp.value = sessionDescription.sdp.toString();  // テキストエリアに表示        
        return peerConnection.setLocalDescription(sessionDescription);  // 生成したOffer SDPを、ローカルに記録。（非同期で処理が行われるので、.then()で受け止める。Promise）
      }).then(function() {
        console.log('Peer: setLocalDescription() succsess in promise');
        // Vanilla ICE の場合には、まだSDPは送らない 
        // Trickle Ice の場合ここで置くる
        // sendSdp(peerConnection.localDescription);   // ローカルSDPを相手に送る。(Trickle ICE 処理)

      }).catch(function(err) {  // エラー
        console.error(err);
      });

  }

  function setOffer(sessionDescription) { // offerメーッセージをリモートSDPにセット
    if (peerConnection) {
      console.error('Peer: peerConnection alreay exist!');
    }
    peerConnection = prepareNewConnection();
    peerConnection.setRemoteDescription(sessionDescription)
    .then(function() {
      console.log('Peer: setRemoteDescription(offer) succsess in promise');
      makeAnswer();
    }).catch(function(err) {
      console.error('Peer: setRemoteDescription(offer) ERROR: ', err);
    });
  }
  
  function makeAnswer() { // Anser SDP を作成し送信する
    console.log('Peer: sending Answer. Creating remote session description...' );
    if (! peerConnection) {
      console.error('Peer: peerConnection NOT exist!');
      return;
    }
    
    peerConnection.createAnswer() //  Answer SDPを生成(非同期処理)
      .then(function (sessionDescription) {
        console.log('Peer: createAnswer() succsess in promise');
        return peerConnection.setLocalDescription(sessionDescription);  // 生成したAnswer SDPをローカルSDPにする。(Promiseを使った非同期処理で行われる。)
      }).then(function() {
        console.log('Peer: setLocalDescription() succsess in promise');
        // Vanilla ICE の場合には、まだSDPは送らない
        // Tricle ICE の場合は送る
        //sendSdp(peerConnection.localDescription); // ローカルSDPを相手に送る(Trickle ICE の場合)

      }).catch(function(err) {
        console.error(err);
      });
  }

  function setAnswer(sessionDescription) {
    if (! peerConnection) {
      console.error('Peer: peerConnection NOT exist!');
      return;
    }

    peerConnection.setRemoteDescription(sessionDescription)
    .then(function() {
      console.log('Peer: setRemoteDescription(answer) succsess in promise');
    }).catch(function(err) {
      console.error('Peer: setRemoteDescription(answer) ERROR: ', err);
    });
  }

  // --- tricke ICE ---
  function addIceCandidate(candidate) {
    if (peerConnection) {
      console.lpg('Peer: addIceCandidate');
      peerConnection.addIceCandidate(candidate);
    }
    else {
      console.error('Peer: PeerConnection not exist!');
      return;
    }
  }
  
</script>
</html>
